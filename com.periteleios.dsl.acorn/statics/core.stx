module statics/core

imports statics/base
imports statics/type

imports signatures/core-sig


signature
  relations 
    mod : Id -> TYPE
      
rules
    
   declOk(s, Module(m, defns)) :- {s_mod}
     new s_mod, s_mod -P-> s,
     declareMod(s, m, MOD(s_mod)),
     defsOk(s_mod, defns).
     
   defOk(s, Import(p)) :- {s_mod s_end}
     typeOfModRef(s, p) == MOD(s_mod),
     s -IMPORT-> s_mod.
                
rules

  declareMod : scope * Id * TYPE
  resolveMod : scope * Id -> list((path * (Id * TYPE)))
  typeOfModRef : scope * Id -> TYPE
  
  declareMod(s, x, T) :- 
    !mod[x, T] in s,
    resolveMod(s, x) == [(_, (_, T))] 
      | error $[Duplicate definition of module [x]], 
    @x.type := T.
    
    
  resolveMod(s, x) = ps :-
    query mod
      filter P* INHERIT*
         and { x' :- x' == x }
         min $ < INHERIT, $ < P, INHERIT < P
         and true
          in s |-> ps.
  
  typeOfModRef(s, x) = T :- {x'} 
    resolveMod(s, x) == [(_,(x', T))|_]
      | error $[Module [x] not defined],
    @x.type := T, @x.ref := x'.
  

